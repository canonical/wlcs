/* Generated by wayland-scanner 1.22.0 */

#ifndef EXT_INPUT_TRIGGER_REGISTRATION_V1_CLIENT_PROTOCOL_H
#define EXT_INPUT_TRIGGER_REGISTRATION_V1_CLIENT_PROTOCOL_H

#include <stdint.h>
#include <stddef.h>
#include "wayland-client-core.h"

#ifdef  __cplusplus
extern "C" {
#endif

/**
 * @page page_ext_input_trigger_registration_v1 The ext_input_trigger_registration_v1 protocol
 * Registration of global input triggers and associated actions
 *
 * @section page_desc_ext_input_trigger_registration_v1 Description
 *
 * This protocol allows for a privileged Wayland client to register ownership
 * of input trigger events and associate them with actions.
 *
 * ext_input_trigger_registration_v1 and the associated ext_input_trigger_action_v1
 * are based on the following discussion document:
 * https://docs.google.com/document/d/1Hj3BXkmW1quIEWqmN7xeJY29nSPfXP2bmoZvpOsEeJQ/
 *
 * @section page_ifaces_ext_input_trigger_registration_v1 Interfaces
 * - @subpage page_iface_ext_input_trigger_registration_manager_v1 - used to register input triggers and actions
 * - @subpage page_iface_ext_input_trigger_v1 - represents the (attempted) registration of an input trigger
 * - @subpage page_iface_ext_input_trigger_action_control_v1 - Allows configuration of an input trigger action
 * @section page_copyright_ext_input_trigger_registration_v1 Copyright
 * <pre>
 *
 * Copyright 2025 Canonical Limited
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * </pre>
 */
struct ext_input_trigger_action_control_v1;
struct ext_input_trigger_registration_manager_v1;
struct ext_input_trigger_v1;

#ifndef EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_INTERFACE
#define EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_INTERFACE
/**
 * @page page_iface_ext_input_trigger_registration_manager_v1 ext_input_trigger_registration_manager_v1
 * @section page_iface_ext_input_trigger_registration_manager_v1_desc Description
 *
 * This interface allows a Wayland client to register ownership of input
 * trigger events and associate them with actions.
 * @section page_iface_ext_input_trigger_registration_manager_v1_api API
 * See @ref iface_ext_input_trigger_registration_manager_v1.
 */
/**
 * @defgroup iface_ext_input_trigger_registration_manager_v1 The ext_input_trigger_registration_manager_v1 interface
 *
 * This interface allows a Wayland client to register ownership of input
 * trigger events and associate them with actions.
 */
extern const struct wl_interface ext_input_trigger_registration_manager_v1_interface;
#endif
#ifndef EXT_INPUT_TRIGGER_V1_INTERFACE
#define EXT_INPUT_TRIGGER_V1_INTERFACE
/**
 * @page page_iface_ext_input_trigger_v1 ext_input_trigger_v1
 * @section page_iface_ext_input_trigger_v1_desc Description
 *
 * In response to the creation of this object the compositor must send
 * either the done or failed event.
 *
 * The done event indicates that the trigger is "owned" by the manager.
 * This means the compositor will not allow this, or any other manager to
 * register the trigger event.
 *
 * The failed event indicates that the trigger is not "owned" by the manager.
 * This the object is of no further use and should be destroyed.
 * @section page_iface_ext_input_trigger_v1_api API
 * See @ref iface_ext_input_trigger_v1.
 */
/**
 * @defgroup iface_ext_input_trigger_v1 The ext_input_trigger_v1 interface
 *
 * In response to the creation of this object the compositor must send
 * either the done or failed event.
 *
 * The done event indicates that the trigger is "owned" by the manager.
 * This means the compositor will not allow this, or any other manager to
 * register the trigger event.
 *
 * The failed event indicates that the trigger is not "owned" by the manager.
 * This the object is of no further use and should be destroyed.
 */
extern const struct wl_interface ext_input_trigger_v1_interface;
#endif
#ifndef EXT_INPUT_TRIGGER_ACTION_CONTROL_V1_INTERFACE
#define EXT_INPUT_TRIGGER_ACTION_CONTROL_V1_INTERFACE
/**
 * @page page_iface_ext_input_trigger_action_control_v1 ext_input_trigger_action_control_v1
 * @section page_iface_ext_input_trigger_action_control_v1_desc Description
 *
 * In response to the creation of this object the compositor must send
 * the done event.
 * @section page_iface_ext_input_trigger_action_control_v1_api API
 * See @ref iface_ext_input_trigger_action_control_v1.
 */
/**
 * @defgroup iface_ext_input_trigger_action_control_v1 The ext_input_trigger_action_control_v1 interface
 *
 * In response to the creation of this object the compositor must send
 * the done event.
 */
extern const struct wl_interface ext_input_trigger_action_control_v1_interface;
#endif

#ifndef EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_CAPABILITY_ENUM
#define EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_CAPABILITY_ENUM
/**
 * @ingroup iface_ext_input_trigger_registration_manager_v1
 * the types of inputs that support triggers
 *
 * This is a bitmask of capabilities this system has; if a member is
 * set, then triggers can be set.
 */
enum ext_input_trigger_registration_manager_v1_capability {
	/**
	 * key combinations can be used as triggers
	 */
	EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_CAPABILITY_KEYBOARD = 0x01,
	/**
	 * keyboard modifier taps and/or holds can be used as triggers
	 */
	EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_CAPABILITY_MODIFIERS = 0x02,
	/**
	 * pointer gestures can be used as triggers
	 */
	EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_CAPABILITY_POINTER = 0x04,
	/**
	 * touch drag gestures can be used as triggers
	 */
	EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_CAPABILITY_TOUCH_DRAG = 0x08,
	/**
	 * touch taps can be used as triggers
	 */
	EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_CAPABILITY_TOUCH_TAP = 0x10,
};
#endif /* EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_CAPABILITY_ENUM */

#ifndef EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_MODIFIERS_ENUM
#define EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_MODIFIERS_ENUM
/**
 * @ingroup iface_ext_input_trigger_registration_manager_v1
 * modifier keys
 *
 * The various shift modifiers on the keyboard
 */
enum ext_input_trigger_registration_manager_v1_modifiers {
	/**
	 * any Alt key
	 */
	EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_MODIFIERS_ALT = 0x01,
	/**
	 * left Alt key
	 */
	EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_MODIFIERS_ALT_LEFT = 0x02,
	/**
	 * Right Alt key
	 */
	EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_MODIFIERS_ALT_RIGHT = 0x04,
	/**
	 * any Shift key
	 */
	EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_MODIFIERS_SHIFT = 0x08,
	/**
	 * left Shift key
	 */
	EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_MODIFIERS_SHIFT_LEFT = 0x10,
	/**
	 * right Shift key
	 */
	EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_MODIFIERS_SHIFT_RIGHT = 0x20,
	/**
	 * Sym key
	 */
	EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_MODIFIERS_SYM = 0x40,
	/**
	 * Function key
	 */
	EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_MODIFIERS_FUNCTION = 0x80,
	/**
	 * any Ctrl key
	 */
	EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_MODIFIERS_CTRL = 0x100,
	/**
	 * left Ctrl key
	 */
	EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_MODIFIERS_CTRL_LEFT = 0x200,
	/**
	 * right Ctrl key
	 */
	EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_MODIFIERS_CTRL_RIGHT = 0x400,
	/**
	 * any Meta key
	 */
	EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_MODIFIERS_META = 0x800,
	/**
	 * left Meta key
	 */
	EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_MODIFIERS_META_LEFT = 0x1000,
	/**
	 * right Meta key
	 */
	EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_MODIFIERS_META_RIGHT = 0x2000,
};
#endif /* EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_MODIFIERS_ENUM */

#ifndef EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_SCREEN_EDGES_ENUM
#define EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_SCREEN_EDGES_ENUM
/**
 * @ingroup iface_ext_input_trigger_registration_manager_v1
 * edge values for pointer_trigger
 *
 * These values are used to indicate which edge of the screen
 * triggers a global input action.
 */
enum ext_input_trigger_registration_manager_v1_screen_edges {
	/**
	 * top edge
	 */
	EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_SCREEN_EDGES_TOP = 1,
	/**
	 * bottom edge
	 */
	EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_SCREEN_EDGES_BOTTOM = 2,
	/**
	 * left edge
	 */
	EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_SCREEN_EDGES_LEFT = 4,
	/**
	 * top left corner
	 */
	EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_SCREEN_EDGES_TOP_LEFT = 5,
	/**
	 * bottom left corner
	 */
	EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_SCREEN_EDGES_BOTTOM_LEFT = 6,
	/**
	 * right edge
	 */
	EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_SCREEN_EDGES_RIGHT = 8,
	/**
	 * top right corner
	 */
	EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_SCREEN_EDGES_TOP_RIGHT = 9,
	/**
	 * bottom right corner
	 */
	EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_SCREEN_EDGES_BOTTOM_RIGHT = 10,
};
#endif /* EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_SCREEN_EDGES_ENUM */

#ifndef EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_DRAG_DIRECTION_ENUM
#define EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_DRAG_DIRECTION_ENUM
/**
 * @ingroup iface_ext_input_trigger_registration_manager_v1
 * directions for drag
 *
 * These values are used to indicate which touch drag direction triggers
 * a global input action.
 */
enum ext_input_trigger_registration_manager_v1_drag_direction {
	/**
	 * upwards
	 */
	EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_DRAG_DIRECTION_UP = 1,
	/**
	 * downwards
	 */
	EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_DRAG_DIRECTION_DOWN = 2,
	/**
	 * leftwards
	 */
	EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_DRAG_DIRECTION_LEFT = 3,
	/**
	 * up to left
	 */
	EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_DRAG_DIRECTION_UP_LEFT = 4,
	/**
	 * down to left
	 */
	EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_DRAG_DIRECTION_DOWN_LEFT = 5,
	/**
	 * rightwards
	 */
	EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_DRAG_DIRECTION_RIGHT = 6,
	/**
	 * up to right
	 */
	EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_DRAG_DIRECTION_UP_RIGHT = 7,
	/**
	 * down to right
	 */
	EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_DRAG_DIRECTION_DOWN_RIGHT = 8,
};
#endif /* EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_DRAG_DIRECTION_ENUM */

/**
 * @ingroup iface_ext_input_trigger_registration_manager_v1
 * @struct ext_input_trigger_registration_manager_v1_listener
 */
struct ext_input_trigger_registration_manager_v1_listener {
	/**
	 * input trigger capabilities
	 *
	 * This is emitted when ext_input_trigger_registration_manager_v1
	 * is bound and whenever a system gains or loses the capabilities.
	 * The argument is a capability enum containing the complete set of
	 * capabilities.
	 * @param capabilities types of inputs that support triggers
	 */
	void (*capabilities)(void *data,
			     struct ext_input_trigger_registration_manager_v1 *ext_input_trigger_registration_manager_v1,
			     uint32_t capabilities);
};

/**
 * @ingroup iface_ext_input_trigger_registration_manager_v1
 */
static inline int
ext_input_trigger_registration_manager_v1_add_listener(struct ext_input_trigger_registration_manager_v1 *ext_input_trigger_registration_manager_v1,
						       const struct ext_input_trigger_registration_manager_v1_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) ext_input_trigger_registration_manager_v1,
				     (void (**)(void)) listener, data);
}

#define EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_DESTROY 0
#define EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_REGISTER_KEYBOARD_SYM_TRIGGER 1
#define EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_REGISTER_KEYBOARD_CODE_TRIGGER 2
#define EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_REGISTER_MODIFIER_HOLD_TRIGGER 3
#define EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_REGISTER_MODIFIER_TAP_TRIGGER 4
#define EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_REGISTER_POINTER_TRIGGER 5
#define EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_REGISTER_TOUCH_DRAG_TRIGGER 6
#define EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_REGISTER_TOUCH_TAP_TRIGGER 7
#define EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_GET_ACTION_CONTROL 8

/**
 * @ingroup iface_ext_input_trigger_registration_manager_v1
 */
#define EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_CAPABILITIES_SINCE_VERSION 1

/**
 * @ingroup iface_ext_input_trigger_registration_manager_v1
 */
#define EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_ext_input_trigger_registration_manager_v1
 */
#define EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_REGISTER_KEYBOARD_SYM_TRIGGER_SINCE_VERSION 1
/**
 * @ingroup iface_ext_input_trigger_registration_manager_v1
 */
#define EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_REGISTER_KEYBOARD_CODE_TRIGGER_SINCE_VERSION 1
/**
 * @ingroup iface_ext_input_trigger_registration_manager_v1
 */
#define EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_REGISTER_MODIFIER_HOLD_TRIGGER_SINCE_VERSION 1
/**
 * @ingroup iface_ext_input_trigger_registration_manager_v1
 */
#define EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_REGISTER_MODIFIER_TAP_TRIGGER_SINCE_VERSION 1
/**
 * @ingroup iface_ext_input_trigger_registration_manager_v1
 */
#define EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_REGISTER_POINTER_TRIGGER_SINCE_VERSION 1
/**
 * @ingroup iface_ext_input_trigger_registration_manager_v1
 */
#define EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_REGISTER_TOUCH_DRAG_TRIGGER_SINCE_VERSION 1
/**
 * @ingroup iface_ext_input_trigger_registration_manager_v1
 */
#define EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_REGISTER_TOUCH_TAP_TRIGGER_SINCE_VERSION 1
/**
 * @ingroup iface_ext_input_trigger_registration_manager_v1
 */
#define EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_GET_ACTION_CONTROL_SINCE_VERSION 1

/** @ingroup iface_ext_input_trigger_registration_manager_v1 */
static inline void
ext_input_trigger_registration_manager_v1_set_user_data(struct ext_input_trigger_registration_manager_v1 *ext_input_trigger_registration_manager_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) ext_input_trigger_registration_manager_v1, user_data);
}

/** @ingroup iface_ext_input_trigger_registration_manager_v1 */
static inline void *
ext_input_trigger_registration_manager_v1_get_user_data(struct ext_input_trigger_registration_manager_v1 *ext_input_trigger_registration_manager_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) ext_input_trigger_registration_manager_v1);
}

static inline uint32_t
ext_input_trigger_registration_manager_v1_get_version(struct ext_input_trigger_registration_manager_v1 *ext_input_trigger_registration_manager_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) ext_input_trigger_registration_manager_v1);
}

/**
 * @ingroup iface_ext_input_trigger_registration_manager_v1
 *
 * This informs the compositor that the input trigger registration manager
 * object will no longer be used. Existing objects created through this
 * interface remain valid.
 */
static inline void
ext_input_trigger_registration_manager_v1_destroy(struct ext_input_trigger_registration_manager_v1 *ext_input_trigger_registration_manager_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) ext_input_trigger_registration_manager_v1,
			 EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) ext_input_trigger_registration_manager_v1), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_ext_input_trigger_registration_manager_v1
 *
 * This request creates an input trigger and asks the compositor to reserve
 * it to the manager. This allows triggering on a character key combination
 * such as "Meta+a".
 *
 * The trigger begins when the combination of modifiers and keysym are
 * pressed and ends when that changes. The keysym parameter is interpreted
 * according to xkbcommon-keysyms.h.
 *
 * The compositor will send either the ext_input_trigger_v1.done or
 * ext_input_trigger_v1.failed event on the created object in
 * response to this request.
 *
 * Input actions triggered by this request will result in an
 * ext_input_trigger_action_v1.begin event when the key combination is
 * depressed and ext_input_trigger_action_v1.end when the key combination
 * changes.
 */
static inline struct ext_input_trigger_v1 *
ext_input_trigger_registration_manager_v1_register_keyboard_sym_trigger(struct ext_input_trigger_registration_manager_v1 *ext_input_trigger_registration_manager_v1, uint32_t modifiers, uint32_t keysym)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) ext_input_trigger_registration_manager_v1,
			 EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_REGISTER_KEYBOARD_SYM_TRIGGER, &ext_input_trigger_v1_interface, wl_proxy_get_version((struct wl_proxy *) ext_input_trigger_registration_manager_v1), 0, modifiers, keysym, NULL);

	return (struct ext_input_trigger_v1 *) id;
}

/**
 * @ingroup iface_ext_input_trigger_registration_manager_v1
 *
 * This request creates an input trigger and asks the compositor to reserve
 * it to the manager. This allows triggering on a specific key combination
 * such "Alt+the-key-above-tab".
 *
 * The trigger begins when the combination of modifiers and keycode are
 * pressed and ends when that changes.
 *
 * The compositor will send either the ext_input_trigger_v1.done or
 * ext_input_trigger_v1.failed event on the created object in
 * response to this request.
 *
 * Input actions triggered by this request will result in an
 * ext_input_trigger_action_v1.begin event when the key combination is
 * depressed and ext_input_trigger_action_v1.end when the key combination
 * changes.
 */
static inline struct ext_input_trigger_v1 *
ext_input_trigger_registration_manager_v1_register_keyboard_code_trigger(struct ext_input_trigger_registration_manager_v1 *ext_input_trigger_registration_manager_v1, uint32_t modifiers, uint32_t keycode)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) ext_input_trigger_registration_manager_v1,
			 EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_REGISTER_KEYBOARD_CODE_TRIGGER, &ext_input_trigger_v1_interface, wl_proxy_get_version((struct wl_proxy *) ext_input_trigger_registration_manager_v1), 0, modifiers, keycode, NULL);

	return (struct ext_input_trigger_v1 *) id;
}

/**
 * @ingroup iface_ext_input_trigger_registration_manager_v1
 *
 * This request creates an input trigger and asks the compositor to reserve
 * it to the manager.
 *
 * This describes a trigger based on holding one or more modifier keys.
 *
 * The compositor will send either the ext_input_trigger_v1.done or
 * ext_input_trigger_v1.failed event on the created object in
 * response to this request.
 *
 * Input actions triggered by this request will result in an
 * ext_input_trigger_action_v1.begin event when triggered
 * and ext_input_trigger_action_v1.end when the trigger ends.
 */
static inline struct ext_input_trigger_v1 *
ext_input_trigger_registration_manager_v1_register_modifier_hold_trigger(struct ext_input_trigger_registration_manager_v1 *ext_input_trigger_registration_manager_v1, uint32_t modifiers)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) ext_input_trigger_registration_manager_v1,
			 EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_REGISTER_MODIFIER_HOLD_TRIGGER, &ext_input_trigger_v1_interface, wl_proxy_get_version((struct wl_proxy *) ext_input_trigger_registration_manager_v1), 0, modifiers, NULL);

	return (struct ext_input_trigger_v1 *) id;
}

/**
 * @ingroup iface_ext_input_trigger_registration_manager_v1
 *
 * This request creates an input trigger and asks the compositor to reserve
 * it to the manager.
 *
 * This describes a trigger based on tapping a modifier key. The tap_count
 * may not be zero.
 *
 * The compositor will send either the ext_input_trigger_v1.done or
 * ext_input_trigger_v1.failed event on the created object in
 * response to this request.
 *
 * Input actions triggered by this request will result in an
 * ext_input_trigger_action_v1.begin event when triggered
 * and ext_input_trigger_action_v1.end when the trigger ends.
 */
static inline struct ext_input_trigger_v1 *
ext_input_trigger_registration_manager_v1_register_modifier_tap_trigger(struct ext_input_trigger_registration_manager_v1 *ext_input_trigger_registration_manager_v1, uint32_t modifier, uint32_t tap_count)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) ext_input_trigger_registration_manager_v1,
			 EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_REGISTER_MODIFIER_TAP_TRIGGER, &ext_input_trigger_v1_interface, wl_proxy_get_version((struct wl_proxy *) ext_input_trigger_registration_manager_v1), 0, modifier, tap_count, NULL);

	return (struct ext_input_trigger_v1 *) id;
}

/**
 * @ingroup iface_ext_input_trigger_registration_manager_v1
 *
 * This request creates an input trigger and asks the compositor to reserve
 * it to the manager.
 *
 * The compositor will send either the ext_input_trigger_v1.done or
 * ext_input_trigger_v1.failed event on the created object in
 * response to this request.
 *
 * Input actions triggered by this request will result in an
 * ext_input_trigger_action_v1.begin event when the pointer is pushed to the
 * target edge(s) and ext_input_trigger_action_v1.end when pointer moves away.
 */
static inline struct ext_input_trigger_v1 *
ext_input_trigger_registration_manager_v1_register_pointer_trigger(struct ext_input_trigger_registration_manager_v1 *ext_input_trigger_registration_manager_v1, uint32_t edges)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) ext_input_trigger_registration_manager_v1,
			 EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_REGISTER_POINTER_TRIGGER, &ext_input_trigger_v1_interface, wl_proxy_get_version((struct wl_proxy *) ext_input_trigger_registration_manager_v1), 0, edges, NULL);

	return (struct ext_input_trigger_v1 *) id;
}

/**
 * @ingroup iface_ext_input_trigger_registration_manager_v1
 *
 * This request creates an input trigger and asks the compositor to reserve
 * it to the manager.
 *
 * This describes a trigger based on dragging three (or more) touchpoints.
 * If advertising the touch_drag capability the compositor must support
 * three touchpoints. Fewer touchpoints are typically reserved for apps,
 * requesting more than three touchpoints may result in a failed event.
 *
 * The compositor will send either the ext_input_trigger_v1.done or
 * ext_input_trigger_v1.failed event on the created object in
 * response to this request.
 *
 * Input actions triggered by this request will result in an
 * ext_input_trigger_action_v1.begin event when the multi-touch moves in the
 * drag direction, ext_input_trigger_action_v1.update as move continues and
 * ext_input_trigger_action_v1.end when touches change.
 */
static inline struct ext_input_trigger_v1 *
ext_input_trigger_registration_manager_v1_register_touch_drag_trigger(struct ext_input_trigger_registration_manager_v1 *ext_input_trigger_registration_manager_v1, uint32_t touches, uint32_t direction)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) ext_input_trigger_registration_manager_v1,
			 EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_REGISTER_TOUCH_DRAG_TRIGGER, &ext_input_trigger_v1_interface, wl_proxy_get_version((struct wl_proxy *) ext_input_trigger_registration_manager_v1), 0, touches, direction, NULL);

	return (struct ext_input_trigger_v1 *) id;
}

/**
 * @ingroup iface_ext_input_trigger_registration_manager_v1
 *
 * This request creates an input trigger and asks the compositor to reserve
 * it to the manager.
 *
 * This describes a trigger based on tapping three (or more) touchpoints.
 * If advertising the touch_tap capability the compositor must support
 * three touchpoints. Fewer touchpoints are typically reserved for apps,
 * requesting more than three touchpoints may result in a failed event.
 *
 * The compositor will send either the ext_input_trigger_v1.done or
 * ext_input_trigger_v1.failed event on the created object in
 * response to this request.
 *
 * Input actions triggered by this request will result in an
 * ext_input_trigger_action_v1.begin and end events when the multi-touch is
 * held for at least hold_delay and released without a touch drag.
 */
static inline struct ext_input_trigger_v1 *
ext_input_trigger_registration_manager_v1_register_touch_tap_trigger(struct ext_input_trigger_registration_manager_v1 *ext_input_trigger_registration_manager_v1, uint32_t touches, uint32_t hold_delay)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) ext_input_trigger_registration_manager_v1,
			 EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_REGISTER_TOUCH_TAP_TRIGGER, &ext_input_trigger_v1_interface, wl_proxy_get_version((struct wl_proxy *) ext_input_trigger_registration_manager_v1), 0, touches, hold_delay, NULL);

	return (struct ext_input_trigger_v1 *) id;
}

/**
 * @ingroup iface_ext_input_trigger_registration_manager_v1
 *
 * This request creates an action control object.
 *
 * The name parameter describes the action (it has no semantic content and
 * may be duplicated across actions).
 *
 * The compositor will send the ext_input_trigger_action_control_v1.done event in
 * response to this request.
 */
static inline struct ext_input_trigger_action_control_v1 *
ext_input_trigger_registration_manager_v1_get_action_control(struct ext_input_trigger_registration_manager_v1 *ext_input_trigger_registration_manager_v1, const char *name)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) ext_input_trigger_registration_manager_v1,
			 EXT_INPUT_TRIGGER_REGISTRATION_MANAGER_V1_GET_ACTION_CONTROL, &ext_input_trigger_action_control_v1_interface, wl_proxy_get_version((struct wl_proxy *) ext_input_trigger_registration_manager_v1), 0, name, NULL);

	return (struct ext_input_trigger_action_control_v1 *) id;
}

/**
 * @ingroup iface_ext_input_trigger_v1
 * @struct ext_input_trigger_v1_listener
 */
struct ext_input_trigger_v1_listener {
	/**
	 * input trigger successfully registered
	 *
	 * This client is now responsible for handling this input
	 * trigger.
	 */
	void (*done)(void *data,
		     struct ext_input_trigger_v1 *ext_input_trigger_v1);
	/**
	 * input trigger failed to register
	 *
	 * The failed event indicates that the trigger is not "owned" by
	 * the manager. This means the object is of no further use and
	 * should be destroyed.
	 */
	void (*failed)(void *data,
		       struct ext_input_trigger_v1 *ext_input_trigger_v1);
};

/**
 * @ingroup iface_ext_input_trigger_v1
 */
static inline int
ext_input_trigger_v1_add_listener(struct ext_input_trigger_v1 *ext_input_trigger_v1,
				  const struct ext_input_trigger_v1_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) ext_input_trigger_v1,
				     (void (**)(void)) listener, data);
}

#define EXT_INPUT_TRIGGER_V1_DESTROY 0

/**
 * @ingroup iface_ext_input_trigger_v1
 */
#define EXT_INPUT_TRIGGER_V1_DONE_SINCE_VERSION 1
/**
 * @ingroup iface_ext_input_trigger_v1
 */
#define EXT_INPUT_TRIGGER_V1_FAILED_SINCE_VERSION 1

/**
 * @ingroup iface_ext_input_trigger_v1
 */
#define EXT_INPUT_TRIGGER_V1_DESTROY_SINCE_VERSION 1

/** @ingroup iface_ext_input_trigger_v1 */
static inline void
ext_input_trigger_v1_set_user_data(struct ext_input_trigger_v1 *ext_input_trigger_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) ext_input_trigger_v1, user_data);
}

/** @ingroup iface_ext_input_trigger_v1 */
static inline void *
ext_input_trigger_v1_get_user_data(struct ext_input_trigger_v1 *ext_input_trigger_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) ext_input_trigger_v1);
}

static inline uint32_t
ext_input_trigger_v1_get_version(struct ext_input_trigger_v1 *ext_input_trigger_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) ext_input_trigger_v1);
}

/**
 * @ingroup iface_ext_input_trigger_v1
 *
 * This informs the compositor that the input trigger will no longer be
 * used.
 */
static inline void
ext_input_trigger_v1_destroy(struct ext_input_trigger_v1 *ext_input_trigger_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) ext_input_trigger_v1,
			 EXT_INPUT_TRIGGER_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) ext_input_trigger_v1), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_ext_input_trigger_action_control_v1
 * @struct ext_input_trigger_action_control_v1_listener
 */
struct ext_input_trigger_action_control_v1_listener {
	/**
	 * the exported action token
	 *
	 * The 'done' event contains the unique token of this action and
	 * notifies that the provider is done. The action token is usable
	 * by the ext_input_trigger_action_v1 protocol. The token can be
	 * used by this or another client (or clients).
	 * @param token the exported action token
	 */
	void (*done)(void *data,
		     struct ext_input_trigger_action_control_v1 *ext_input_trigger_action_control_v1,
		     const char *token);
};

/**
 * @ingroup iface_ext_input_trigger_action_control_v1
 */
static inline int
ext_input_trigger_action_control_v1_add_listener(struct ext_input_trigger_action_control_v1 *ext_input_trigger_action_control_v1,
						 const struct ext_input_trigger_action_control_v1_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) ext_input_trigger_action_control_v1,
				     (void (**)(void)) listener, data);
}

#define EXT_INPUT_TRIGGER_ACTION_CONTROL_V1_ADD_INPUT_TRIGGER_EVENT 0
#define EXT_INPUT_TRIGGER_ACTION_CONTROL_V1_DROP_INPUT_TRIGGER_EVENT 1
#define EXT_INPUT_TRIGGER_ACTION_CONTROL_V1_CANCEL 2
#define EXT_INPUT_TRIGGER_ACTION_CONTROL_V1_DESTROY 3

/**
 * @ingroup iface_ext_input_trigger_action_control_v1
 */
#define EXT_INPUT_TRIGGER_ACTION_CONTROL_V1_DONE_SINCE_VERSION 1

/**
 * @ingroup iface_ext_input_trigger_action_control_v1
 */
#define EXT_INPUT_TRIGGER_ACTION_CONTROL_V1_ADD_INPUT_TRIGGER_EVENT_SINCE_VERSION 1
/**
 * @ingroup iface_ext_input_trigger_action_control_v1
 */
#define EXT_INPUT_TRIGGER_ACTION_CONTROL_V1_DROP_INPUT_TRIGGER_EVENT_SINCE_VERSION 1
/**
 * @ingroup iface_ext_input_trigger_action_control_v1
 */
#define EXT_INPUT_TRIGGER_ACTION_CONTROL_V1_CANCEL_SINCE_VERSION 1
/**
 * @ingroup iface_ext_input_trigger_action_control_v1
 */
#define EXT_INPUT_TRIGGER_ACTION_CONTROL_V1_DESTROY_SINCE_VERSION 1

/** @ingroup iface_ext_input_trigger_action_control_v1 */
static inline void
ext_input_trigger_action_control_v1_set_user_data(struct ext_input_trigger_action_control_v1 *ext_input_trigger_action_control_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) ext_input_trigger_action_control_v1, user_data);
}

/** @ingroup iface_ext_input_trigger_action_control_v1 */
static inline void *
ext_input_trigger_action_control_v1_get_user_data(struct ext_input_trigger_action_control_v1 *ext_input_trigger_action_control_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) ext_input_trigger_action_control_v1);
}

static inline uint32_t
ext_input_trigger_action_control_v1_get_version(struct ext_input_trigger_action_control_v1 *ext_input_trigger_action_control_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) ext_input_trigger_action_control_v1);
}

/**
 * @ingroup iface_ext_input_trigger_action_control_v1
 *
 * This request adds an input trigger to those that activate the action.
 */
static inline void
ext_input_trigger_action_control_v1_add_input_trigger_event(struct ext_input_trigger_action_control_v1 *ext_input_trigger_action_control_v1, struct ext_input_trigger_v1 *trigger)
{
	wl_proxy_marshal_flags((struct wl_proxy *) ext_input_trigger_action_control_v1,
			 EXT_INPUT_TRIGGER_ACTION_CONTROL_V1_ADD_INPUT_TRIGGER_EVENT, NULL, wl_proxy_get_version((struct wl_proxy *) ext_input_trigger_action_control_v1), 0, trigger);
}

/**
 * @ingroup iface_ext_input_trigger_action_control_v1
 *
 * This request drops an input trigger from those that activate the action.
 */
static inline void
ext_input_trigger_action_control_v1_drop_input_trigger_event(struct ext_input_trigger_action_control_v1 *ext_input_trigger_action_control_v1, struct ext_input_trigger_v1 *trigger)
{
	wl_proxy_marshal_flags((struct wl_proxy *) ext_input_trigger_action_control_v1,
			 EXT_INPUT_TRIGGER_ACTION_CONTROL_V1_DROP_INPUT_TRIGGER_EVENT, NULL, wl_proxy_get_version((struct wl_proxy *) ext_input_trigger_action_control_v1), 0, trigger);
}

/**
 * @ingroup iface_ext_input_trigger_action_control_v1
 *
 * This informs the compositor that the input trigger action will no
 * longer be used.
 *
 * Any ext_input_trigger_action_v1 created from the associated token
 * by this or other clients will become unavailable.
 */
static inline void
ext_input_trigger_action_control_v1_cancel(struct ext_input_trigger_action_control_v1 *ext_input_trigger_action_control_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) ext_input_trigger_action_control_v1,
			 EXT_INPUT_TRIGGER_ACTION_CONTROL_V1_CANCEL, NULL, wl_proxy_get_version((struct wl_proxy *) ext_input_trigger_action_control_v1), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_ext_input_trigger_action_control_v1
 *
 * This informs the compositor that the input trigger action will no
 * longer be used.
 * Any ext_input_trigger_action_v1 created from the associated token
 * by this or other clients will be unaffected.
 */
static inline void
ext_input_trigger_action_control_v1_destroy(struct ext_input_trigger_action_control_v1 *ext_input_trigger_action_control_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) ext_input_trigger_action_control_v1,
			 EXT_INPUT_TRIGGER_ACTION_CONTROL_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) ext_input_trigger_action_control_v1), WL_MARSHAL_FLAG_DESTROY);
}

#ifdef  __cplusplus
}
#endif

#endif
